using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using NUnit.Framework;
using Renci.SshNet;
using Renci.SshNet.Security;
using SshNet.Keygen.Extensions;
using SshNet.Keygen.SshKeyEncryption;

namespace SshNet.Keygen.Tests
{
    public class TestKey
    {
        [Test]
        public void TestExceptions()
        {
            Assert.Throws<CryptographicException>(() => SshKey.Generate<RsaKey>());
            Assert.Throws<CryptographicException>(() => SshKey.Generate<EcdsaKey>());
            Assert.Throws<CryptographicException>(() => SshKey.Generate<RsaKey>(1));
            Assert.Throws<CryptographicException>(() => SshKey.Generate<ED25519Key>(1));
            Assert.Throws<CryptographicException>(() => SshKey.Generate<EcdsaKey>(1));
        }

        [Test]
        public void TestDefaultKey()
        {
            var key = SshKey.Generate();
            Assert.IsInstanceOf<RsaKey>(key);
            Assert.AreEqual(2048, key.KeyLength);
            Assert.DoesNotThrow(() =>
            {
                new PrivateKeyFile(key.ToOpenSshFormat().ToStream());
            });
        }

        private void KeyGenTest<TKey>(int keyLength = 0) where TKey : Key, new()
        {
            const string password = "12345";
            var cases = new List<ISshKeyEncryption>()
            {
                new SshKeyEncryptionAes256(password),
                new SshKeyEncryptionAes256(password, Aes256Mode.Cbc),
                new SshKeyEncryptionAes256(password, Aes256Mode.Ctr),
                new SshKeyEncryptionNone()
            };

            foreach (var @case in cases)
            {
                var key = SshKey.Generate<TKey>(keyLength);
                if (keyLength != 0)
                    Assert.AreEqual(keyLength, (key.KeyLength));

                var privateKey = key.ToOpenSshFormat(@case, "Generated by SshNet.Keygen");
                var publicKey = key.ToOpenSshPublicFormat("Generated by SshNet.Keygen");
                TestContext.WriteLine($"Run: {@case}");
                TestContext.WriteLine(privateKey);
                TestContext.WriteLine(publicKey);

                // File.WriteAllText("test-key", privateKey);
                // File.WriteAllText("test-key.pub", publicKey);

                var keyFile = new PrivateKeyFile(privateKey.ToStream(), password);
                Assert.IsInstanceOf<TKey>(((KeyHostAlgorithm) keyFile.HostKey).Key);
                if (keyLength != 0)
                    Assert.AreEqual(keyLength, (((KeyHostAlgorithm) keyFile.HostKey).Key.KeyLength));
            }
        }

        [Test]
        public void GenerateED25519Key()
        {
            KeyGenTest<ED25519Key>();
        }

        [Test]
        public void GenerateRSA2048()
        {
            KeyGenTest<RsaKey>(2048);
        }

        [Test]
        public void GenerateRSA3072()
        {
            KeyGenTest<RsaKey>(3072);
        }

        [Test]
        public void GenerateRSA4096()
        {
            KeyGenTest<RsaKey>(4096);
        }

        [Test]
        public void GenerateRSA8192()
        {
            KeyGenTest<RsaKey>(8192);
        }

        [Test]
        public void GenerateEcdsa256()
        {
            KeyGenTest<EcdsaKey>(256);
        }

        [Test]
        public void GenerateEcdsa384()
        {
            KeyGenTest<EcdsaKey>(384);
        }

        [Test]
        public void GenerateEcdsa521()
        {
            KeyGenTest<EcdsaKey>(521);
        }

        private string GetKey(string keyname)
        {
            var resourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(string.Format("SshNet.Keygen.Tests.TestKeys.{0}", keyname));
            using (var reader = new StreamReader(resourceStream, Encoding.ASCII))
            {
                return reader.ReadToEnd();
            }
        }

        private void TestFormatKey<T>(string keyname, int keyLength, string passphrase = null)
        {
            if (!string.IsNullOrEmpty(passphrase))
                keyname = $"{keyname}.encrypted";

            var keydata = GetKey(keyname);
            var pubkeydata = GetKey($"{keyname}.pub");
            var fpMd5Data = GetKey($"{keyname}.fingerprint.md5");
            var fpSha1Data = GetKey($"{keyname}.fingerprint.sha1");
            var fpSha256Data = GetKey($"{keyname}.fingerprint.sha256");
            var fpSha384Data = GetKey($"{keyname}.fingerprint.sha384");
            var fpSha512Data = GetKey($"{keyname}.fingerprint.sha512");
            var keyFile = new PrivateKeyFile(keydata.ToStream(), passphrase);

            var key = ((KeyHostAlgorithm) keyFile.HostKey).Key;

            Assert.IsInstanceOf<T>(key);
            Assert.AreEqual(keyLength, key.KeyLength);
            Assert.AreEqual(pubkeydata.Trim(), keyFile.ToOpenSshPublicFormat().Trim());
            Assert.AreEqual(fpSha256Data.Trim(), keyFile.Fingerprint().Trim());
            Assert.AreEqual(fpMd5Data.Trim(), keyFile.Fingerprint(HashAlgorithmName.MD5).Trim());
            Assert.AreEqual(fpSha1Data.Trim(), keyFile.Fingerprint(HashAlgorithmName.SHA1).Trim());
            Assert.AreEqual(fpSha256Data.Trim(), keyFile.Fingerprint(HashAlgorithmName.SHA256).Trim());
            Assert.AreEqual(fpSha384Data.Trim(), keyFile.Fingerprint(HashAlgorithmName.SHA384).Trim());
            Assert.AreEqual(fpSha512Data.Trim(), keyFile.Fingerprint(HashAlgorithmName.SHA512).Trim());

            // XXX: We cannot test the result of the PrivateKey Export, since Random CheckInts are random...
            //      So just check the key can be reimport again.
            // Assert.AreEqual(keydata.Trim(), keyFile.ToOpenSshFormat().Trim());
            var export = string.IsNullOrEmpty(passphrase)
                ? keyFile.ToOpenSshFormat()
                : keyFile.ToOpenSshFormat(new SshKeyEncryptionAes256(passphrase));
            Assert.DoesNotThrow(() =>
            {
                new PrivateKeyFile(export.ToStream(), passphrase);
            });
        }

        [Test]
        public void TestRSA2048()
        {
            TestFormatKey<RsaKey>("RSA2048", 2048);
            TestFormatKey<RsaKey>("RSA2048", 2048, "12345");
        }

        [Test]
        public void TestRSA3072()
        {
            TestFormatKey<RsaKey>("RSA3072", 3072);
            TestFormatKey<RsaKey>("RSA3072", 3072, "12345");
        }

        [Test]
        public void TestRSA4096()
        {
            TestFormatKey<RsaKey>("RSA4096", 4096);
            TestFormatKey<RsaKey>("RSA4096", 4096, "12345");
        }

        [Test]
        public void TestRSA8192()
        {
            TestFormatKey<RsaKey>("RSA8192", 8192);
            TestFormatKey<RsaKey>("RSA8192", 8192, "12345");
        }

        [Test]
        public void TestECDSA256()
        {
            TestFormatKey<EcdsaKey>("ECDSA256", 256);
            TestFormatKey<EcdsaKey>("ECDSA256", 256, "12345");
        }

        [Test]
        public void TestECDSA384()
        {
            TestFormatKey<EcdsaKey>("ECDSA384", 384);
            TestFormatKey<EcdsaKey>("ECDSA384", 384, "12345");
        }

        [Test]
        public void TestECDSA521()
        {
            TestFormatKey<EcdsaKey>("ECDSA521", 521);
            TestFormatKey<EcdsaKey>("ECDSA521", 521, "12345");
        }

        [Test]
        public void TestED25519()
        {
            TestFormatKey<ED25519Key>("ED25519", 256);
            TestFormatKey<ED25519Key>("ED25519", 256, "12345");
        }
    }
}